        -:    0:Source:tree.c
        -:    0:Graph:tree.gcno
        -:    0:Data:tree.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "tree.h"
        -:    2:
        -:    3:struct private_node
        -:    4:{
        -:    5:    private_node* prev_;
        -:    6:    private_node* left_;
        -:    7:    private_node* right_;
        -:    8:    node* data_;
        -:    9:    int key_;
        -:   10:};
        -:   11:
        -:   12:struct tree
        -:   13:{
        -:   14:    struct private_node* root_;
        -:   15:};
        -:   16:
        -:   17://Fault injection malloc
        -:   18:void* mymalloc(int size);
        -:   19://prev - parent node, prev_pos - position relatively to parent node
        -:   20:private_node* tree_search_private(tree* tree, int key, private_node** prev, private_node*** prev_pos);
        -:   21:private_node* search_next_private(tree* tree, int key);
        -:   22:private_node* tree_min_private(private_node* root);
        -:   23:private_node* tree_max_private(private_node* root);
        -:   24:void print_private(private_node* root);
        -:   25:void tree_destroy_private(private_node* root);
        -:   26:static int foreach_private(private_node* root, int(*func)(node* node));
        -:   27:
      178:   28:void* mymalloc(int size)
        -:   29:{
        -:   30:    static int counter = 0;
      178:   31:    if (counter % 5 == 3)
        -:   32:    {
       36:   33:        counter++;
       36:   34:        return NULL;
        -:   35:    }
        -:   36:
      142:   37:    counter++;
      142:   38:    return calloc(1, size);
        -:   39:}
        -:   40:
       10:   41:tree* new_tree()
        -:   42:{
       10:   43:    tree* new = (tree*)mymalloc(sizeof(tree));
       10:   44:    if (new == NULL)
        -:   45:    {
        2:   46:        return NULL;
        -:   47:    }
        8:   48:    new->root_ = NULL;
        8:   49:    return new;
        -:   50:}
        -:   51:
       86:   52:int tree_insert(tree* tree, int key, node* data_node)
        -:   53:{
       86:   54:    if (tree == NULL)
        2:   55:        return -1;
        -:   56:
       84:   57:    private_node* new = (private_node*)mymalloc(sizeof(private_node));
       84:   58:    node* tmp = (node*)mymalloc(sizeof(node));
       84:   59:    if (new == NULL || tmp == NULL)
        -:   60:    {
       34:   61:        free(new);
       34:   62:        free(tmp);
       34:   63:        return -1;
        -:   64:    }
       50:   65:    tmp->data_ = data_node->data_;
       50:   66:    new->key_ = key;
       50:   67:    new->data_ = tmp;
        -:   68:
       50:   69:    private_node* prev = NULL;
        -:   70:    private_node** rubish;
       50:   71:    private_node* cur = tree_search_private(tree, key, &prev, &rubish);
       50:   72:    if (cur != NULL)
        -:   73:    {
       10:   74:        free(new);
       10:   75:        free(tmp);
       10:   76:        return -1;
        -:   77:    }
        -:   78:
        -:   79:
       40:   80:    new->prev_ = prev;
       40:   81:    if (prev == NULL)
        -:   82:    {
        2:   83:        tree->root_ = new;
        -:   84:    }
       38:   85:    else if (new->key_ < prev->key_)
        -:   86:    {
       14:   87:        prev->left_ = new;
        -:   88:    }
        -:   89:    else
        -:   90:    {
       24:   91:        prev->right_ = new;
        -:   92:    }
        -:   93:
       40:   94:    return 0;
        -:   95:}
        -:   96:
       18:   97:int tree_delete(tree* tree, int key)
        -:   98:{
       18:   99:    if (tree == NULL)
        2:  100:        return -1;
        -:  101:
       16:  102:    private_node** prev_pos = NULL;
        -:  103:    private_node* rubish;
       16:  104:    private_node* cur = tree_search_private(tree, key, &rubish, &prev_pos);
       16:  105:    if (cur == NULL)
        -:  106:    {
        2:  107:        return -1;
        -:  108:    }
        -:  109:
       14:  110:    if (cur->left_ == NULL && cur->right_ == NULL)
        -:  111:    {
        4:  112:        *prev_pos = NULL;
        -:  113:    }
       10:  114:    else if (cur->left_ != NULL && cur->right_ == NULL)
        -:  115:    {
        2:  116:        *prev_pos = cur->left_;
        -:  117:    }
        8:  118:    else if (cur->left_ == NULL && cur->right_ != NULL)
        -:  119:    {
        2:  120:        *prev_pos = cur->right_;
        -:  121:    }
        -:  122:    else
        -:  123:    {
        6:  124:        private_node* next = search_next_private(tree, key);
        6:  125:        if (next == cur->right_)
        -:  126:        {
        2:  127:            *prev_pos = next;
        2:  128:            next->left_ = cur->left_;
        -:  129:        }
        -:  130:        else
        -:  131:        {
        4:  132:            next->prev_->left_ = next->right_;
        4:  133:            if (prev_pos != NULL)
        -:  134:            {
        2:  135:                *prev_pos = next;
        -:  136:            }
        -:  137:            else
        -:  138:            {
        2:  139:                tree->root_ = next;
        -:  140:            }
        -:  141:
        4:  142:            next->left_ = cur->left_;
        4:  143:            next->right_ = cur->right_;
        -:  144:        }
        -:  145:    }
        -:  146:
       14:  147:    free(cur->data_);
       14:  148:    free(cur);
       14:  149:    return 0;
        -:  150:}
        -:  151:
       12:  152:node* tree_search(tree* tree, int key)
        -:  153:{
       12:  154:    if (tree == NULL)
        2:  155:        return NULL;
        -:  156:
        -:  157:    private_node* rubish1;
        -:  158:    private_node** rubish2;
       10:  159:    private_node* result = tree_search_private(tree, key, &rubish1, &rubish2);
       10:  160:    if (result == NULL)
        -:  161:    {
        2:  162:        return NULL;
        -:  163:    }
        -:  164:
        8:  165:    return result->data_;
        -:  166:}
        -:  167:
       90:  168:private_node* tree_search_private(tree* tree, int key, private_node** prev, private_node*** prev_pos)
        -:  169:{
       90:  170:    private_node* cur = tree->root_;
      384:  171:    while (cur != NULL && cur->key_ != key)
        -:  172:    {
      204:  173:        *prev = cur;
      204:  174:        if (key < cur->key_)
        -:  175:        {
       92:  176:            *prev_pos = &(cur->left_);
       92:  177:            cur = cur->left_;
        -:  178:        }
        -:  179:        else
        -:  180:        {
      112:  181:            *prev_pos = &(cur->right_);
      112:  182:            cur = cur->right_;
        -:  183:        }
        -:  184:    }
        -:  185:
       90:  186:    return cur;
        -:  187:}
        -:  188:
       10:  189:int search_next(tree* tree, int key)
        -:  190:{
       10:  191:    if (tree == NULL)
        2:  192:        return -1;
        -:  193:
        8:  194:    private_node* result = search_next_private(tree, key);
        8:  195:    if (result == NULL)
        -:  196:    {
        2:  197:        errno = EINVAL;
        2:  198:        return -1;
        -:  199:    }
        -:  200:
        6:  201:    return result->key_;
        -:  202:}
        -:  203:
       14:  204:private_node* search_next_private(tree* tree, int key)
        -:  205:{
        -:  206:    private_node* rubish1;
        -:  207:    private_node** rubish2;
       14:  208:    private_node* cur = tree_search_private(tree, key, &rubish1, &rubish2);
       14:  209:    if (cur == NULL)
        -:  210:    {
        2:  211:        return NULL;
        -:  212:    }
        -:  213:
       12:  214:    if (cur->right_ != NULL)
        -:  215:    {
        8:  216:        return tree_min_private(cur->right_);
        -:  217:    }
        -:  218:
        4:  219:    private_node* prev = cur->prev_;
       10:  220:    while (prev != NULL && cur == prev->right_)
        -:  221:    {
        2:  222:        cur = prev;
        2:  223:        prev = prev->prev_;
        -:  224:    }
        -:  225:
        4:  226:    return prev;
        -:  227:}
        -:  228:
        6:  229:int tree_min(tree* tree)
        -:  230:{
        6:  231:    if (tree == NULL)
        2:  232:        return -1;
        -:  233:
        4:  234:    private_node* result = tree_min_private(tree->root_);
        4:  235:    if (result == NULL)
        -:  236:    {
        2:  237:        errno = EINVAL;
        2:  238:        return -1;
        -:  239:    }
        -:  240:
        2:  241:    return result->key_;
        -:  242:}
        -:  243:
       12:  244:private_node* tree_min_private(private_node* root)
        -:  245:{
       12:  246:    if (root == NULL)
        -:  247:    {
        2:  248:        return NULL;
        -:  249:    }
        -:  250:
       10:  251:    private_node* cur = root;
       32:  252:    while (cur->left_ != NULL)
        -:  253:    {
       12:  254:        cur = cur->left_;
        -:  255:    }
        -:  256:
       10:  257:    return cur;
        -:  258:}
        -:  259:
        6:  260:int tree_max(tree* tree)
        -:  261:{
        6:  262:    if (tree == NULL)
        2:  263:        return -1;
        -:  264:
        4:  265:    private_node* result = tree_max_private(tree->root_);
        4:  266:    if (result == NULL)
        -:  267:    {
        2:  268:        errno = EINVAL;
        2:  269:        return -1;
        -:  270:    }
        -:  271:
        2:  272:    return result->key_;
        -:  273:}
        -:  274:
        4:  275:private_node* tree_max_private(private_node* root)
        -:  276:{
        4:  277:    if (root == NULL)
        -:  278:    {
        2:  279:        return NULL;
        -:  280:    }
        -:  281:
        2:  282:    private_node* cur = root;
        8:  283:    while (cur->right_ != NULL)
        -:  284:    {
        4:  285:        cur = cur->right_;
        -:  286:    }
        -:  287:
        2:  288:    return cur;
        -:  289:}
        -:  290:
       18:  291:void print(tree* tree)
        -:  292:{
       18:  293:    if (tree != NULL)
        -:  294:    {
       16:  295:        print_private(tree->root_);
        -:  296:    }
       18:  297:}
        -:  298:
      404:  299:void print_private(private_node* root)
        -:  300:{
      404:  301:    private_node* cur = root;
      404:  302:    if (cur != NULL)
        -:  303:    {
      194:  304:        print_private(cur->left_);
      194:  305:        printf("{%d, %c} ", cur->key_, cur->data_->data_);
      194:  306:        print_private(cur->right_);
        -:  307:    }
      404:  308:}
        -:  309:
        8:  310:void tree_destroy(tree** tree)
        -:  311:{
        8:  312:    if (tree != NULL && (*tree)->root_ != NULL)
        -:  313:    {
        2:  314:        tree_destroy_private((*tree)->root_);
        2:  315:        (*tree)->root_ = NULL;
        -:  316:    }
        -:  317:
        8:  318:    free(*tree);
        8:  319:    *tree = NULL;
        8:  320:}
        -:  321:
       26:  322:void tree_destroy_private(private_node* root)
        -:  323:{
       26:  324:    if (root->left_ != NULL)
        -:  325:    {
        8:  326:        tree_destroy_private(root->left_);
        -:  327:    }
        -:  328:
       26:  329:    if (root->right_ != NULL)
        -:  330:    {
       16:  331:        tree_destroy_private(root->right_);
        -:  332:    }
        -:  333:
       26:  334:    free(root->data_);
       26:  335:    free(root);
       26:  336:}
        -:  337:
        4:  338:int foreach(tree* tree, int(*func)(node* node))
        -:  339:{
        4:  340:    if (tree != NULL)
        -:  341:    {
        2:  342:        return foreach_private(tree->root_, func);
        -:  343:    }
        -:  344:    
        2:  345:    return -1;
        -:  346:}
        -:  347:
       54:  348:int foreach_private(private_node* root, int(*func)(node* node))
        -:  349:{
       54:  350:    private_node* cur = root;
       54:  351:    int result = 0;
       54:  352:    if (cur != NULL)
        -:  353:    {
       26:  354:        result = 1;
       26:  355:        result += foreach_private(cur->left_, func);
       26:  356:        func(cur->data_);
       26:  357:        result += foreach_private(cur->right_, func);
        -:  358:    }
        -:  359:
       54:  360:    return result;
        -:  361:}
